free c:channel.

type key.
type epoch.
type counter.
type sessionkey.

free keyid:key [private].

query attacker(keyid).

fun sessionKeyGen(key, epoch):sessionkey.
fun MAC(sessionkey, counter, bitstring): bitstring.
fun epoch2bitstring(epoch):bitstring [data,typeConverter].


let sender(ep:epoch, cnt:counter, keyid:key)=
    new msg: bitstring; 
    let sk = sessionKeyGen(keyid, ep) in
    let mac=MAC(sk, cnt,msg) in
    out(c,(cnt,msg));
    out(c,(c,mac));
    in(c,authfail:bool);
    if authfail = true then
       new ep:epoch;
       new cnt:counter;
       out(c,(cnt,ep));
       
       let verifmac=MAC(sk,cnt,epoch2bitstring(ep)) in
       out(c,(c,verifmac));
       out(c,(cnt,msg));
       out(c,(c,mac))
(*
	use keys to get sessionkey
	new msg
	send cid data
	send cid, mac
	if authfail 
	   new ep, cnt
	   	
*)
.
let receiver(ep:epoch, cnt:counter, keyid:key)=
    let sk=sessionKeyGen(keyid,ep) in 
    in(c,(cnt:counter,msg:bitstring));
    in(c,(xcnt:counter, mac:bitstring));
    let maccheck=MAC(sk,cnt,msg) in
    if maccheck<>mac then
    out(c,true);
    in(c,(=xcnt,=ep));
    in (c,(=xcnt,verifmac:bitstring));
    let maccheck=MAC(sk,xcnt,epoch2bitstring(ep)) in 
    if maccheck=verifmac then
       let sk=sessionKeyGen(keyid,ep) in 
       in(c,(=cnt,msg:bitstring));
       in(c,(xcnt:counter, mac:bitstring));
       let maccheck=MAC(sk,cnt,msg) in
       if maccheck<>mac then
       0
    
    
    (*
    use key to get session key 
    receive cid+data
    receive c+mac
    if mac<>MAC(data)
       out false
       in cid, ep
       in cid verifmac 
       if <> mac then 0 else 
       	  new sessionkey
       	  in cid, data
	  in cid, mac, 
	  verify new mac 
    *)
.
process
	new ep:epoch;
	new cnt:counter;
	new keyid:key;
	(
		(!sender(ep,cnt,keyid)) | (!receiver(ep,cnt,keyid))
	)
	