free c:channel.

type key.
type epoch.
type counter.
type sessionkey.

free keyid:key [private].

query attacker(keyid).

fun sessionKeyGen(key, epoch):sessionkey.
fun sessionKeyGenBS(key, bitstring):sessionkey.
fun MAC(sessionkey, counter, bitstring): bitstring.
fun epoch2bitstring(epoch):bitstring [data,typeConverter].

event authSuccess(sessionkey,bitstring).
event macChecked(sessionkey,bitstring).



query sk:sessionkey, mac:bitstring; event(authSuccess(sk,mac))==>event(macChecked(sk,mac)).

(*StatVerif stuff*)
free zero:bitstring.
free one:bitstring.
free two:bitstring.
free three:bitstring.

cell senderC:bitstring:= zero.
cell senderE:bitstring:=zero.
(*Session key gen 
	  eid++
	  gen mac 
	  reset counter to 0
update counters
       if cid=4
       	  if eid=4
	     eid=0
	  else
	     eid++
	   cid=0
	   call keygen
        else 
	    cid++
*)

letfun plusplus(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=three then zero.

(*out (eidpp,SK)*)
letfun session_key_gen(eid:bitstring)=
    let eidpp:bitstring = plusplus(eid) in
    let sk = sessionKeyGenBS(keyid, eidpp) in
    (eidpp,sk)
.
       
(*letfun session_key_gen(e:bitstring*)
(*Code for repeated functions 
       session_key_gen
-----------------------------------
    lock senderE;
    read senderE as eid:bitstring;
    if eid=zero then
       senderE:=one
    else if eid=one then
       senderE:=two
    else if eid=two then
       senderE:=three
    else senderE:=zero;
    read senderE as eid:bitstring;
    let sk = sessionKeyGenBS(keyid, eid) in
    senderC:=zero;


    update_counters()   
-----------------------------------
    read senderC as cid:bitstring;
    if cid=three then (  
       if eid = three then
       	  senderE :=zero
       else 
	 if eid=zero then
       	    senderE:=one
   	 else if eid=one then
       	    senderE:=two
    	 else senderE:=three; 
       senderC:=zero) 
    else 
	if cid=zero then
       	    senderC:=one
   	 else if cid=one then
       	    senderC:=two
    	 else senderC:=three;    
*)

let sender(ep:epoch, cnt:counter, keyid:key)=
(*session_key_gen()*)
    lock senderE;
    lock senderC;
    read senderE as eid; 
    let (eidpp:bitstring, sk:sessionkey) = session_key_gen(eid) in
    senderE:=eidpp;
    senderC:=zero;  
    (*Update_counters()*)
    read senderC as cid:bitstring;
    if cid=three then (  
       if eid = three then
       	  senderE :=zero
       else let eidpp2:bitstring = plusplus(eidpp) in senderE:=eidpp2;
       senderC:=zero;
       let (eidpp2:bitstring, sk:sessionkey) = session_key_gen(eidpp) in
       senderE:=eidpp2;
       senderC:=zero
    )
    else 
	let cidpp = plusplus(cid) in
	    senderC:=cidpp;
   
    new msg:bitstring;
    
   	let mac=MAC(sk, cnt,msg) in
    	(*Send counter/ msg and then mac*)
    	out(c,(cnt,msg));
	     out(c,(cnt,mac));
    	     in(c,authfail:bool);
    	     if authfail = true then
       	     (*
       	     update counters()
       	     *)
       	     new newep:epoch;
       	     new newcnt:counter;
       	     let newsk = sessionKeyGen(keyid,newep) in
       	     (*Broadcast Counters to resync them*)
       	     out(c,(newcnt,newep));
       	     (*Send new mac to verify*)
       	     let verifmac=MAC(newsk,newcnt,epoch2bitstring(newep)) in
       	     out(c,(newcnt,verifmac))
       	     (*Process can be restarted*)
	         else
		 	event authSuccess(sk,mac)
		
.
let receiver(ep:epoch, ocnt:counter, keyid:key)=
    let sk=sessionKeyGen(keyid,ep) in
    (*Receive counter and msg*)
    in(c,(cnt:counter,msg:bitstring));
    in(c,(=cnt, mac:bitstring));
    let maccheck=MAC(sk,cnt,msg) in
    if maccheck=mac then
       event macChecked(sk,maccheck);
       0
    else
    (*Macs did not match, counters must be out of sync. Auth_Fail*)
    out(c,true);
    in(c,(newcnt:counter,newep:epoch));
    in (c,(=newcnt,verifmac:bitstring));
    let newsk=sessionKeyGen(keyid,newep) in
    (*Check macs*)
    let maccheck2=MAC(sk,newcnt,epoch2bitstring(newep)) in
    (* counters resynced, process can restart*)
    if maccheck2=verifmac then
        0
.
process
	new ep:epoch;
	new cnt:counter;
	(
		(!sender(ep,cnt,keyid)) | (!receiver(ep,cnt,keyid))
	)
	