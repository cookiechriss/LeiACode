free c:channel.

type key.
type epoch.
type counter.
type sessionkey.

free keyid:key [private].

query attacker(keyid).

fun sessionKeyGen(key, bitstring):sessionkey.
fun sessionKeyGenBS(key, bitstring):sessionkey.
fun MAC(sessionkey, bitstring, bitstring): bitstring.
fun epoch2bitstring(epoch):bitstring [data,typeConverter].

event authSuccess(sessionkey,bitstring).
event macChecked(sessionkey,bitstring).



query sk:sessionkey, mac:bitstring; event(authSuccess(sk,mac))==>event(macChecked(sk,mac)).

(*StatVerif stuff*)
free zero:bitstring.
free one:bitstring.
free two:bitstring.
free three:bitstring.

cell senderC:bitstring:= zero.
cell senderE:bitstring:=zero.
(*Session key gen 
	  eid++
	  gen mac 
	  reset counter to 0
update counters
       if cid=4
       	  if eid=4
	     eid=0
	  else
	     eid++
	   cid=0
	   call keygen
        else 
	    cid++
*)

letfun plusplus(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=three then zero
.

letfun session_key_gen(eid:bitstring)=
       let eidpp:bitstring = plusplus(eid) in
       let sk = sessionKeyGenBS(keyid, eidpp) in
       (eidpp,sk)
.
letfun update_counters(cid:bitstring,eid:bitstring, sk:sessionkey)=
       if cid=three then (
       	  (*plusplus handles the overflow
       	  if eid = three then
       	     newE=zero 
       	  else  let eidpp:bitstring = plusplus(eid) in senderE:=eidpp2;*)
       	  let (eidpp:bitstring, newsk:sessionkey) = session_key_gen(eid) in
	  (zero,eidpp, newsk)
	)
    	else let cidpp = plusplus(cid) in (cidpp,eid,sk)
.

let sender(ep:bitstring, cnt:bitstring, keyid:key)=
(*session_key_gen()*)
    lock senderE;
    lock senderC;
    read senderE as eid; 
    let (eidpp:bitstring, sk:sessionkey) = session_key_gen(eid) in
    senderE:=eidpp;
    senderC:=zero;  
    (*Update_counters()*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(zero,eidpp, sk) in
    senderC:=cid1;
    senderE:=eid1;

    new msg:bitstring;
    let mac=MAC(newsk,cid1,msg) in
    (*Send counter/ msg and then mac*)
    out(c,(cid1,msg));
    out(c,(cid1,mac));
    in(c,authfail:bool);
    if authfail = true then
       (*update counters()*)
       let (cid2:bitstring,eid2:bitstring,newsk2:sessionkey) = update_counters(cid1,eid1, newsk) in
       senderC:=cid2;
       senderE:=eid2;
       (*Broadcast Counters to resync them*)
       out(c,(cid2,eid2));
       (*Send new mac to verify*)
       let verifmac=MAC(newsk2,cid2,eid2) in
       out(c,(cid2,verifmac))
       (*Process can be restarted*)
    else
       	event authSuccess(sk,mac)
		
.
let receiver(ep:bitstring, ocnt:bitstring, keyid:key)=
    let sk=sessionKeyGen(keyid,ep) in
    (*Receive counter and msg*)
    in(c,(cnt:bitstring,msg:bitstring));
    in(c,(=cnt, mac:bitstring));
    let maccheck=MAC(sk,cnt,msg) in
    if maccheck=mac then
       event macChecked(sk,maccheck);
       0
    else
    (*Macs did not match, counters must be out of sync. Auth_Fail*)
    out(c,true);
    in(c,(newcnt:bitstring,newep:bitstring));
    in (c,(=newcnt,verifmac:bitstring));
    let newsk=sessionKeyGen(keyid,newep) in
    (*Check macs*)
    let maccheck2=MAC(sk,newcnt,newep) in
    (* counters resynced, process can restart*)
    if maccheck2=verifmac then
        0
.
process
	new ep:bitstring;
	new cnt:bitstring;
	(
		(!sender(ep,cnt,keyid)) | (!receiver(ep,cnt,keyid))
	)
	