set debugOutput=false.
free c:channel.

type key.
type epoch.
type counter.
type sessionkey.

free keyid:key [private].

query attacker(keyid).

fun sessionKeyGen(key, bitstring):sessionkey.
fun sessionKeyGenBS(key, bitstring):sessionkey.
fun MAC(sessionkey, bitstring, bitstring): bitstring.
fun epoch2bitstring(epoch):bitstring [data,typeConverter].

event authSuccess(sessionkey,bitstring).
event macChecked(sessionkey,bitstring).



query sk:sessionkey, mac:bitstring; event(authSuccess(sk,mac))==>event(macChecked(sk,mac)).

(*StatVerif stuff*)
free zero:bitstring.
free one:bitstring.
free two:bitstring.
free three:bitstring.

cell senderC:bitstring:= zero.
cell senderE:bitstring:=zero.

cell receiverC:bitstring:= zero.
cell receiverE:bitstring:=zero.
(*Session key gen 
	  eid++
	  gen mac 
	  reset counter to 0
update counters
       if cid=4
       	  if eid=4
	     eid=0
	  else
	     eid++
	   cid=0
	   call keygen
        else 
	    cid++
*)

letfun plusplus(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=three then zero
.

letfun session_key_gen(eid:bitstring)=
       let eidpp:bitstring = plusplus(eid) in
       let sk = sessionKeyGenBS(keyid, eidpp) in
       (eidpp,sk)
.
letfun update_counters(cid:bitstring,eid:bitstring, sk:sessionkey)=
       if cid=three then (
       	  (*plusplus handles the overflow
       	  if eid = three then
       	     newE=zero 
       	  else  let eidpp:bitstring = plusplus(eid) in senderE:=eidpp2;*)
       	  let (eidpp:bitstring, newsk:sessionkey) = session_key_gen(eid) in
	  (zero,eidpp, newsk)
	)
    	else let cidpp = plusplus(cid) in (cidpp,eid,sk)
.
letfun isGreatherThan(x:bitstring, y:bitstring)=
       if x = zero then y
       else if x=one  && (y=two || y=three) then y
       else if x=two && y=three then y
       else x      	  
.
let sender(keyid:key)=
(*session_key_gen()*)
    lock senderE;
    lock senderC;
    read senderE as eid; 
    let (eidpp:bitstring, sk:sessionkey) = session_key_gen(eid) in
    senderE:=eidpp;
    senderC:=zero;  
    (*Update_counters()*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(zero,eidpp, sk) in
    senderC:=cid1;
    senderE:=eid1;

    new msg:bitstring;
    let mac=MAC(newsk,cid1,msg) in
    (*Send counter/ msg and then mac*)
    out(c,(cid1,msg));
    out(c,(cid1,mac));
    in(c,authfail:bool);
    if authfail = true then
       (*update counters()*)
       let (cid2:bitstring,eid2:bitstring,newsk2:sessionkey) = update_counters(cid1,eid1, newsk) in
       senderC:=cid2;
       senderE:=eid2;
       (*Broadcast Counters to resync them*)
       out(c,(cid2,eid2));
       (*Send new mac to verify*)
       let verifmac=MAC(newsk2,cid2,eid2) in
       out(c,(cid2,verifmac))
       (*Process can be restarted*)
    else
       	event authSuccess(sk,mac)
		
.
let receiver(keyid:key)=
    lock receiverE;
    lock receiverC;
    read receiverE as eid; 
    let (eidpp:bitstring, sk:sessionkey) = session_key_gen(eid) in
    receiverE:=eidpp;
    receiverC:=zero;  
    (*Update_counters()*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(zero,eidpp, sk) in
    receiverC:=cid1;
    receiverE:=eid1;
    
    
    (*Receive counter and msg*)

(*add some code which only updades cid and eid if senders is larger*)
    in(c,(scid:bitstring,msg:bitstring));
    in(c,(=scid, mac:bitstring));
    let maccheck=MAC(newsk,cid1,msg) in
    if maccheck=mac then
       event macChecked(newsk,maccheck);
       0
    else
    (*Macs did not match, counters must be out of sync. Auth_Fail*)
    out(c,true);
    in(c,(scid1:bitstring,seid:bitstring));
    let cid2=isGreatherThan(cid1,scid1) in
    let eid2=isGreatherThan(eid1,scid1) in
    
    in (c,(=cid2,verifmac:bitstring));
    
    let newsk=sessionKeyGen(keyid,cid2) in
    (*Check macs*)
    let maccheck2=MAC(sk,cid2,eid2) in
    (* counters resynced, process can restart*)
    if maccheck2=verifmac then
       out(c,keyid);
        0
.
process
	(
		(!sender(keyid)) | (!receiver(keyid))
	)





(*To do: add code to update counters if they are less than the ones received
     	 update variables to new ones ifthey have changed 
	 change the process to init the sender and receiver counters*)