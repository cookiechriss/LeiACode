set verboseClauses=short.
set debugOutput=false.
free c:channel.

type key.
type epoch.
type counter.
type sessionkey.

free keyid:key [private].

query attacker(keyid).

fun sessionKeyGen(key, bitstring):sessionkey.
fun sessionKeyGenBS(key, bitstring):sessionkey.
fun MAC(sessionkey, bitstring, bitstring): bitstring.
fun epoch2bitstring(epoch):bitstring [data,typeConverter].

event authSuccess(sessionkey,bitstring).
event macChecked(sessionkey,bitstring).



query sk:sessionkey, mac:bitstring; event(authSuccess(sk,mac))==>event(macChecked(sk,mac)).

(*StatVerif stuff*)
free zero:bitstring.
free one:bitstring.
free two:bitstring.
free three:bitstring.

cell senderC:bitstring:= zero.
cell senderE:bitstring:=zero.

cell receiverC:bitstring:= zero.
cell receiverE:bitstring:=zero.

letfun plusplus(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=three then zero
.

letfun session_key_gen(eid:bitstring)=
       let eidpp:bitstring = plusplus(eid) in
       let sk = sessionKeyGenBS(keyid, eidpp) in
       (eidpp,sk)
.
letfun update_counters(cid:bitstring,eid:bitstring, sk:sessionkey)=
       if cid=three then (
       	  (*plusplus handles the overflow
       	  if eid = three then
       	     newE=zero
       	  else  let eidpp:bitstring = plusplus(eid) in senderE:=eidpp2;*)
       	  let (eidpp:bitstring, newsk:sessionkey) = session_key_gen(eid) in
	  (zero,eidpp, newsk)
	)
    	else let cidpp = plusplus(cid) in (cidpp,eid,sk)
.
letfun isGreatherThan(x:bitstring, y:bitstring)=
       if x = zero then y
       else if x=one  && (y=two || y=three) then y
       else if x=two && y=three then y
       else x
.
let sender(keyid:key)=

new msg:bitstring;
(*session_key_gen()*)
    lock senderE;
    lock senderC;
    read senderE as eid;
    read senderC as cid;
    let (eidpp:bitstring, sk:sessionkey) = session_key_gen(eid) in
    (*Update_counters()*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(cid,eidpp, sk) in
    senderC:=zero;
    senderE:=eid1;

    (*Sending authenticated messages*)
    out(c,(cid1,msg));
    let mac=MAC(newsk,cid1,msg) in
    out(c,(cid1,mac));

    (*AUTH_FAIL received*)
    in(c,authfail:bool);
    if authfail = true then
       (*update counters()*)
       let (cid2:bitstring,eid2:bitstring,newsk2:sessionkey) = update_counters(cid1,eid1, newsk) in
       senderC:=cid2;
       senderE:=eid2;
       unlock senderC;
       unlock senderE;
       (*Broadcast Counters to resync them*)
       out(c,(cid2,eid2));
       (*Send new mac to verify*)
       let verifmac=MAC(newsk2,cid2,eid2) in
       out(c,(cid2,verifmac))
       (*Process can be restarted*)
    else
	unlock senderC;
        unlock senderE;
       	event authSuccess(sk,mac)

.
let receiver(keyid:key)=
(*session_key_gen()*)
    lock receiverE;
    lock receiverC;
    read receiverE as eid;
    let (eidpp:bitstring, sk:sessionkey) = session_key_gen(eid) in
    receiverE:=eidpp;
    receiverC:=zero;
(*Update_counters()*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(zero,eidpp, sk) in
    receiverC:=cid1;
    receiverE:=eid1;
    (* error_outOfMemory.txt
    out(c,keyid); *)

    (*Receive counter and msg*)
    in(c,(scid:bitstring,msg:bitstring));
    in(c,(=scid, mac:bitstring));
    let maccheck=MAC(newsk,cid1,msg) in
    if maccheck=mac then
       (*Authentication is successful*)
       unlock receiverC;
       unlock receiverE;
       event macChecked(newsk,maccheck);
       0
    else
    (*Auth_Fail*)
    out(c,true);
    in(c,(scid1:bitstring,seid1:bitstring));
    let cid2=isGreatherThan(cid1,scid1) in
    let eid2=isGreatherThan(eid1,seid1) in
    receiverC:=cid2;
    receiverE:=eid2;
    unlock receiverC;
    unlock receiverE;

    in (c,(=cid2,verifmac:bitstring));

    let newsk2=sessionKeyGen(keyid,eid2) in
    (*Check macs*)
    let maccheck2=MAC(newsk2,cid2,eid2) in
    (* counters resynced, process can restart*)
    if maccheck2=verifmac then

    (*might need to verify the message again??*)
       (* runs for 10+ mins and generates a segmentation fault

       out(c,keyid);*)
        0
.
process
	(
		(!sender(keyid)) | (!receiver(keyid))
	)
