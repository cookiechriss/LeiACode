
set debugOutput=false.
free c:channel.

type key.
type epoch.
type counter.
type sessionkey.

free keyid:key [private].

query attacker(keyid).

fun sessionKeyGen(key, bitstring):sessionkey.
fun sessionKeyGenBS(key, bitstring):sessionkey.
fun MAC(sessionkey, bitstring, bitstring): bitstring.
fun epoch2bitstring(epoch):bitstring [data,typeConverter].

event authSuccess(sessionkey,bitstring).
event macChecked(sessionkey,bitstring).



query sk:sessionkey, mac:bitstring; event(authSuccess(sk,mac))==>event(macChecked(sk,mac)).

(*StatVerif stuff*)
free zero:bitstring.
free one:bitstring.
free two:bitstring.

cell senderSK:sessionkey.
cell senderC:bitstring:= zero.
cell senderE:bitstring:=zero.

cell receiverSK:sessionkey.
cell receiverC:bitstring:= zero.
cell receiverE:bitstring:=zero.

letfun plusplus(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=two then zero

.

letfun session_key_gen(eid:bitstring)=
       let eidpp:bitstring = plusplus(eid) in
       let sk = sessionKeyGenBS(keyid, eidpp) in
       (eidpp,sk)
.
letfun update_counters(cid:bitstring,eid:bitstring, sk:sessionkey)=
       if cid=two then (
       	  (*
       	  if eid = two then
       	     newE=zero
       	  else  let eidpp:bitstring = plusplus(eid) in *)
       	  let (eidpp:bitstring, newsk:sessionkey) = session_key_gen(eid) in
	  (zero,eidpp, newsk)
	)
    	else let cidpp = plusplus(cid) in (cidpp,eid,sk)
.
letfun isGreatherThan(x:bitstring, y:bitstring)=
       if x = zero then y
       else if x=one  && (y=two) then y
       else x
.
let sender()=
    (*The message to send*)
    new msg:bitstring;
    read senderE as eid;
    read senderC as cid;
    read senderSK as sk;
    (*Update_counters()*) (*Session key gen resets counter to 0*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(cid,eid, sk) in
    lock senderC;
    lock senderE;
    lock senderSK;
    senderSK:=newsk;
    senderC:=cid1;
    senderE:=eid1;
    unlock senderC;
    unlock senderE;
    unlock senderSK;    
    (*Sending authenticated messages*)
    let mac=MAC(newsk,cid1,msg) in
    out(c,(cid1,msg));
    out(c,(cid1,mac));

    (*AUTH_FAIL received*)
    in(c,authfail:bool);
    if authfail = true then
       0
    else
       	event authSuccess(sk,mac)

.
let receiver()=
(*session_key_gen()*)
    read receiverE as eid;
    read receiverC as cid;
    read receiverSK as sk;
(*Update_counters()*)
    let (cid1:bitstring,eid1:bitstring,newsk:sessionkey) = update_counters(cid,eid, sk) in
    lock receiverC;
    lock receiverE;
    lock receiverSK;
    receiverSK:=newsk;
    receiverC:=cid1;
    receiverE:=eid1;
    unlock receiverSK;
    unlock receiverE;
    unlock receiverC;
    (* error_outOfMemory.txt
    out(c,keyid); *)

    (*Receive counter and msg*)
    in(c,(scid:bitstring,msg:bitstring));
    in(c,(=scid, mac:bitstring));
    let maccheck=MAC(newsk,cid1,msg) in
    if maccheck=mac then
       (*Authentication is successful*)
       unlock receiverC;
       unlock receiverE;
       event macChecked(newsk,maccheck);
       0
    else
    (*Auth_Fail*)
    out(c,true)
.
process
	(*Init to zero and then set the sk, counter and epoch*)
	let (eidpp:bitstring, sk:sessionkey)=session_key_gen(zero) in
	senderSK:=sk;
	senderE:=eidpp;
	senderC:=zero;
	receiverSK:=sk;
	receiverE:=eidpp;
	receiverC:=zero;
	
	(
		(!sender()) | (!receiver())
	)
