set debugOutput=true.
free c:channel.

type key.
type sessionkey.

free keyid:key [private].
free zero:bitstring.
free one:bitstring.
free two:bitstring.
free authfail:bitstring [private].
fun sessionKeyGen(key, bitstring):sessionkey.
fun MAC(sessionkey, bitstring, bitstring): bitstring.

cell senC:bitstring.
cell recC:bitstring.
cell senE:bitstring.
cell recE:bitstring.
cell senSK:sessionkey.
cell recSK:sessionkey.

query attacker(keyid).
(*
event authSuccess(sessionkey,bitstring).
event macChecked(sessionkey,bitstring).
query sk:sessionkey, mac:bitstring; event(authSuccess(sk,mac))==>event(macChecked(sk,mac)).*)
letfun pp(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=two then zero
.
letfun session_key_gen(eid:bitstring)=
       let eidpp:bitstring = pp(eid) in
       let sk = sessionKeyGen(keyid, eidpp) in
       (eidpp,sk)
.
letfun update_counters(cid:bitstring,eid:bitstring, sk:sessionkey)=
       if cid=two then (
       	  (*plusplus handles the overflow
       	  if eid = two then
       	     newE=zero
       	  else  let eidpp:bitstring = plusplus(eid) in senderE:=eidpp2;*)
       	  let (eidpp:bitstring, newsk:sessionkey) = session_key_gen(eid) in
	  (zero,eidpp, newsk)
	)
    	else let cidpp = pp(cid) in (cidpp,eid,sk)
.
letfun isGreatherThan(x:bitstring, y:bitstring)=
       if x = zero then y
       else if x=one  && (y=two) then y
       else x
.

let s()=
    new msg:bitstring;
    read senC as cid;
    read senE as eid;
    read senSK as sk;
    let (cid1:bitstring, eid1:bitstring, newsk:sessionkey) = update_counters(cid, eid, sk) in
    
    senC:=cid1;
    senC:=eid1;
    senSK:=newsk;
    
    out(c,(cid1, msg));
    out(c,(cid1,MAC(newsk,cid1,msg)));
    in(c,reply:bitstring);
    if reply=authfail then
       let (cid2:bitstring, eid2:bitstring, newsk2:sessionkey) = update_counters(cid1, eid1, newsk) in

       senC:=cid2;
       senC:=eid2;
       senSK:=newsk2;

       out(c,(cid2,eid2));
       out(c,(cid2,MAC(newsk2,cid2,eid2)));


       out(c,(cid2,msg));
       out(c,(cid2,MAC(newsk2,cid2,msg)));
       
       
       0
    else
	(*event authSuccess(newsk,MAC(newsk,cid1,msg))*)
	0
.

let r()=
    read recC as cid;
    read recE as eid;
    read recSK as sk;
    let (cid1:bitstring, eid1:bitstring, newsk:sessionkey) = update_counters(cid, eid, sk) in

    recC:=cid1;
    recC:=eid1;
    recSK:=newsk;

    in(c,(scid:bitstring,msg:bitstring));
    in(c,(=scid,mac:bitstring));
(*    if scid<>cid1 then*)
    let maccheck=MAC(newsk, cid1,msg) in
    if mac=maccheck then
       (*event macChecked(newsk,maccheck);*)
       
       0
    else
	out(c, authfail);
	in(c,(scid1:bitstring,seid1:bitstring));
	in(c,(=scid1,mac2:bitstring));
	
	let cid2=isGreatherThan(cid1,scid1) in
    	let eid2=isGreatherThan(eid1,seid1) in
	let newsk2=sessionKeyGen(keyid, eid2) in
	let verifmac=MAC(newsk2,scid1, seid1) in
	if verifmac=mac2 then 
    	    recC:=cid2;
	    recC:=eid2;
	    recSK:=newsk2;

	    in(c, (=scid1, msg2:bitstring));
	    in(c, (=scid1, mac3:bitstring));
	    let finalmac = MAC(newsk2,cid2, msg2) in
	    	if finalmac=mac3 then
		   0(*verified*)
		else
				0
	    else
		0
	
.
 
process

	senC:=zero;
	recC:=zero;
	senE:=one;
	recE:=one;
	senSK:=sessionKeyGen(keyid, one);
	recSK:=sessionKeyGen(keyid, one);
	(
		(!s)|(!r)
	)