free c:channel.

type key.
type sessionkey.

free keyid:key [private].
free zero:bitstring.
free one:bitstring.
free two:bitstring.
free authfail:bitstring [private].
fun sessionKeyGen(key, bitstring):sessionkey.
fun MAC(sessionkey, bitstring, bitstring): bitstring.

cell senC:bitstring.
cell recC:bitstring.

letfun plusplus(x:bitstring)=
       if x=zero then one
       else if x=one then two
       else if x=two then zero
.
query attacker(keyid).
let s()=
    read senC as cid;
    let eid = one in
    let sk:sessionkey = sessionKeyGen(keyid, eid) in
    let eid1 = two in
    let cid1 = one in

    lock senC;
    senC:=cid1;
    unlock senC;
    
    new msg:bitstring;
    out(c,(cid1, msg));
    out(c,(cid1,MAC(sk,cid1,msg)));
    in(c,reply:bitstring);
    if reply=authfail then
       out(c,keyid)
.

let r()=
    read recC as cid;
    let eid = one in
    let sk:sessionkey = sessionKeyGen(keyid, eid) in
    let eid1 = two in
    let cid1 = one in

    lock recC;
    recC:=cid1;
    unlock recC;

    in(c,(scid:bitstring,msg:bitstring));
    in(c,(=scid,mac:bitstring));
(*    if scid<>cid1 then*)
    let maccheck=MAC(sk, cid1,msg) in
    if mac=maccheck then
       out(c,keyid)
    else
	
	(*out(c, authfail)*)
	0
.

process

	senC:=zero;
	recC:=zero;
	(
		(!s)|(!r)
	)